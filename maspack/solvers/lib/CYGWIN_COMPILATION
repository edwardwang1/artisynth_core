Notes on compiling solver libraries on Windows using Cygwin
-----------------------------------------------------------

Update for July 31, 2014
------------------------

Intel MKL 11 proved to be difficult to compile using MingGW, because
of unreolved symbols in the MKL binary xerbla.obj.  These symbols
included __security_check_cookie and __GSHandlerCheck.

A discussion about security check code is given in

http://www.codeproject.com/Articles/1854/Compiler-Security-Checks-In-Depth

Some threads indicated that this could be solved by linking with
libraries such as secchk.lib or bufferoverflow.lib or
bufferoverflowU.lib.

In addition, there was a "bad reloc address" error, and a very large
number of warnings of the form

   Warning: .drectve `-defaultlib:"uuid.lib" ' unrecognized

An attempt to get around the problem by redefining xerbla.obj also
proved elusive. In the end, we decided to simply use the Intel
compiler because it can be purchaed for the same cost as MKL.  See
INTEL_COMPILATION.

Nov 11, 2012
------------

Windows compilation is done using Cygwin. You should be able to simply
run 'make', and the Makefile will detect the Cygwin install and set
the build parameters appropriately.

One of the main issues in compling the solver library is the need to
create a native Windows dll - i.e., one that does not rely on any
cygwin runtime libraries. There are two ways to do this:

1) Use Visual C++, which we have done, and a Visual C++ project lives
   in the directory SolversPardisoMkl_MSVC32

2) Use the MinGW compilers, specifically:

   x86_64-w64-mingw32-g++, x86_64-w64-mingw32-gcc - 32 bit systems
   i686-w64-mingw32-g++, i686-w64-mingw32-gcc - 64 bit systems

   These are now available as cywgin packages

The remainder of this document describes issues that arise in
configuring a successful compilation using the MinGW compilers.

1) The main MKL libraries required for a Pardiso application appear
   to be (for MKL 10.X) 

   mkl_intel_c.lib 
   mkl_intel_thread.lib 
   mkl_core.lib
   libiomp5md.lib

2) The following options are supplied to the MinGW compilers: (see
   also http://gcc.gnu.org/onlinedocs/gcc/i386-and-x86_002d64-Options.html\
   #i386-and-x86_002d64-Options.)

   -static-libstdc++, -static-libgcc: statically include the C and C++
       runtimes into the output.

   -mwindows: (Not needed): specifies that a GUI application is to be
       generated by instructing the linker to set the PE header
       subsystem type appropriately.

   -m64: sets int to 32 bits and long and pointer types to 64 bits,
       and generates code for the x86-64 architecture.
 
   -Wl,--add-stdcall-alias: Loader option that specifies that when
       dlltool is creating the exports file it shouldadd aliases for
       stdcall symbols without @ <number> in addition to the symbols
       with @ <number>.

   -shared: tells the loader to create a shared library

   -DCYGWIN: compile switch indicating a CYGWIN compilation.

3) In order to inspect what external dlls are required by a given .exe
   or .dll, you can use Dependency Walker (depends.exe;
   www.dependencywalker.com). Just download, unzip, create a shortcut
   to depends.exe, and open any .exe or .dll file you like.

4) Because these were compiled using some flavour of native Windows
   compiler, they rely on some symbols like __chkstk (check stack) and
   __allmul (64bit integer multiply) that are normally provided by the
   Windows runtime. We supply these symbols directly using
   chkstk_XX.obj and llmul_XX.obj (where XX is either 32 or 64), which
   were extracted from the Visual C++ libraries. Specifically, they
   were obtained from

   VisualC++RootDir/VC/lib/chkstk.obj
   VisualC++RootDir/VC/lib/libcmt.lib

5) To inspect symbols and modules inside .obj and .lib files, one can
   use dumpbin.exe and lib.exe, which live in VisualC++RootDir/VC/bin.
   These must be run from a Visual Stdio Command prompt to ensure that
   paths and environment variables are properly set up:

   > Start Menu > All Programs > Visual Studio XXX > Visual Studio Command Prompt

6) To find symbols, use

   > dumpbin.exe /symbols file.obj

   The output can be routed to a file using >, or piped through findstr:

   > dumpbin.exe /symbols \path\to\file | findstr symbolName

7) To find objects in a library, use
 
   > lib.exe /list libfile.lib

   To extract a .obj file, use

   > lib.exe libfile.lib /extract:exactObjNameInLib /out:outputObjName

8) On Windows, the call to random() in pardisoTest and pardiso4Test
   must be replaced by a call to rand() (which is done using an #ifdef CYGWIN).

9) When compiling, you need JAVA_HOME to be set to the root of your
   Java installation (e.g., C:\Program Files\Java\jdk1.6.0_30), so
   that jni.h, etc. can be located.

   If JAVA_HOME is not defined, it will be set within the Makefile to some
   (likely incorrect) value.

9) When compiling, you need MKL_HOME to be set to the root of your MKL
   library directory (e.g., C:/Intel/Composer XE"). It is assumed that
   mkl/lib/ia32 is reachable from MKL_HOME.

   If MKL_HOME is not defined, it will be set within the Makefile to some
   (likely incorrect) value.

10) In some cases external libraries created with Visual studio (like
   the no longer used pardiso400_INTEL_IA32.lib) cannot be directly
   linked with gcc:
   http://stackoverflow.com/questions/1138170/use-libraries-compiled-with-visual-studio-in-an-application-compiled-by-g-ming,
   therefore we have to build our own import library:
   http://www.emmestech.com/moron_guides/moron1.html

   pexports can be downloaded from here:
   http://www.emmestech.com/software/pexports-0.43/download_pexports.html

   create import library:
   $ cd $ARTISYNTH_HOME/lib/Windows
   $ pexports.exe pardiso400_INTEL_IA32.dll > pardiso400_INTEL_IA32.def
   $ dlltool --input-def pardiso400_INTEL_IA32.def  --dllname pardiso400_INTEL_IA32.dll --output-lib pardiso400_INTEL_IA32.a -k
   $ rablib pardiso400_INTEL_IA32.a

   Thanks to Ian Stavness for doing the leg work on this.

11) Since it was compiled using an Intel compiler, Pardiso 4 exports
   its entry points as PARDISO and PARDISOINIT, vs.  pardiso_ and
   pardisoinit_ for the earlier version of Pardiso.

12) Overall compilation and testing is done from a Cygwin shell as

   $ cd $ARTISYNTH_HOME/src/maspack/solvers/lib
   $ make pardisoMklTest
   $ ./pardisoMklTest
   $ make libs

13) At present, loading causes a number of warning of the form

   Warning: .drectve `-defaultlib:"uuid.lib" ' unrecognized

   This appears to be in response to a directive inserted by MSVC into
   its obj files, requested the use of a particular library, but which
   is unknown or unsupported by MinGW. As long as everything links
   properly, it appears that this can be safely ignored.

14) If there is a crash with a 64-bit compile, it is necessary to
   debug it using a mingw gdb configured for 64 bits. In particular,
   x86_64-w64-mingw32-gdb-7.0.50.20100202.tar.bz2 (available online)
   contains bin/gdb.exe, which is configured for 64-bit executables.

15) Statically loading libiomp5md.lib caused a SEGV in
   omp_get_num_procs() in the 64-bit version. It is not clear why this
   is, but dynamically loading libiomp5md (with -liomp5md) and then
   putting libiomp5md.dll in Windows64 fixed the problem.

--------------------------------------------------------------------

http://sourceforge.net/projects/mingw-w64/forums/forum/723797/topic/4546995:

   At present, MSVC-generated x64 *.lib files are not supported; Kai may
   have more to say about that. If you must link to MSVC- generated x64
   *.dll files, please use "gendef" tool to generate GNU-ld compatible
   lib*.a files and use them instead.



